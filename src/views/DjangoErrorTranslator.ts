// Generated by Khrysalis TypeScript converter - this file will be overwritten.
// File: views/DjangoErrorTranslator.kt
// Package: com.lightningkite.butterfly.views
import { checkIsInterface } from '../Kotlin'
import { Observable, TimeoutError, of as rxOf } from 'rxjs'
import { xResponseReadText } from '../net/RxHttpAssist'
import { xResponseCodeGet } from '../net/HttpResponse'
import { StringBuilder, xCharIsUpperCase } from '../kotlin/kotlin.text'
import { ViewString, ViewStringRaw, ViewStringResource } from './ViewString'
import { map as rxMap } from 'rxjs/operators'
import { xStringFromJsonStringUntyped } from '../Codable'
import { HttpResponseException } from '../net/HttpResponseError'

//! Declares com.lightningkite.butterfly.views.DjangoErrorTranslator
export class DjangoErrorTranslator {
    public readonly connectivityErrorResource: string;
    public readonly serverErrorResource: string;
    public readonly otherErrorResource: string;
    public constructor(connectivityErrorResource: string, serverErrorResource: string, otherErrorResource: string) {
        this.connectivityErrorResource = connectivityErrorResource;
        this.serverErrorResource = serverErrorResource;
        this.otherErrorResource = otherErrorResource;
    }
    
    
    public handleNode(builder: StringBuilder, node: (any | null)): void {
        if (node === null) { return }
        if (checkIsInterface<Map<(any | null), (any | null)>>(node!, "KotlinCollectionsMap")){
            for (const toDestructure of (node as Map<(any | null), (any | null)>)) {
                const key = toDestructure[0]
                const value = toDestructure[1]
                
                this.handleNode(builder, value)
                
            }
        } else if (checkIsInterface<Array<(any | null)>>(node!, "KotlinCollectionsList")){
            for (const value of (node as Array<(any | null)>)) {
                this.handleNode(builder, value);
            }
        } else if (typeof (node!) == "string"){
            //Rough check for human-readability - sentences start with uppercase and will have spaces
            if ((node as string) !== "" && xCharIsUpperCase((node as string)[0]) && ((node as string).indexOf(" ") != -1)) {
                builder.value += (node as string) + '\n';
            }
        }
    }
    public parseError(code: number, error: (string | null)): ViewString {
        switch(code / 100) {
            case 0:
            return new ViewStringResource(this.connectivityErrorResource)
            case 1:
            case 2:
            case 3:
            
            break;
            case 4:
            const errorJson = ((): (any | null) => {
                    if(error !== null) {
                        return xStringFromJsonStringUntyped(error)
                    } else { return null }
            })();
            
            if (errorJson !== null) {
                const builder = new StringBuilder();
                
                this.handleNode(builder, errorJson);
                return new ViewStringRaw(builder.toString());
            } else {
                return new ViewStringRaw(error ?? "");
            }
            break;
            case 5:
            return new ViewStringResource(this.serverErrorResource)
            default:
            
            break;
        }
        
        return new ViewStringResource(this.otherErrorResource);
    }
    
    public wrap<T>(callback:  ((result: (T | null), error: (ViewString | null)) => void)): ((code: number, result: (T | null), error: (string | null)) => void) {
        return (code: number, result: (T | null), error: (string | null)): void => {
            callback(result, this.parseError(code, error));
        };
    }
    
    public wrapNoResponse(callback:  ((error: (ViewString | null)) => void)): ((code: number, error: (string | null)) => void) {
        return (code: number, error: (string | null)): void => {
            callback(this.parseError(code, error));
        };
    }
    
    public parseException(exception: any): Observable<ViewString> {
        return ((): Observable<ViewString> => {
                if (exception instanceof HttpResponseException) {
                    return xResponseReadText((exception as HttpResponseException).response).pipe(rxMap((it: string): ViewString => this.parseError(xResponseCodeGet((exception as HttpResponseException).response), it)))
                } else if (exception instanceof TimeoutError) {
                    return rxOf(new ViewStringResource(this.connectivityErrorResource))
                } else  {
                    return rxOf(new ViewStringResource(this.otherErrorResource))
                }
        })();
    }
}

