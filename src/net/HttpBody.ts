// Generated by Butterfly TypeScript converter
// File: net/HttpBody.kt
// Package: com.lightningkite.butterfly.net
import {Codable, xAnyToJsonString} from '../Codable'
import {HttpMediaType, HttpMediaTypes} from './HttpMediaType'
import {stringify} from "./jsonParsing";
import {Observable, of} from "rxjs";
import {Image, ImageImageBitmap} from "../Image";
import {xImageLoad} from "../Image.loadingRx";
import {flatMap, map} from "rxjs/operators";
import {Exception, IllegalArgumentException} from "../kotlin/Language";

//! Declares com.lightningkite.butterfly.net.HttpBody
export class HttpBody {
    data: BodyInit;
    type: HttpMediaType;

    constructor(data: BodyInit, type: HttpMediaType) {
        this.data = data;
        this.type = type;
    }

    getBlobOrString(): Blob | string {
        if (typeof this.data === "string") {
            return this.data
        } else if (this.data instanceof Blob) {
            return this.data
        } else if (this.data instanceof ArrayBuffer) {
            return new Blob([this.data])
        } else if (this.data instanceof Int8Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Int16Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Int32Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Uint8Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Uint16Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Uint32Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Float32Array) {
            return new Blob([this.data])
        } else if (this.data instanceof Float64Array) {
            return new Blob([this.data])
        } else {
            throw new IllegalArgumentException(`Can't transform ${this.data} into a blob or string.`, undefined)
        }
    }
}

//! Declares com.lightningkite.butterfly.net.HttpBodyPart
export class HttpBodyPart {
    name: string;
    value: string | null;
    filename: string | null;
    body: HttpBody;
}


//! Declares com.lightningkite.butterfly.net.toJsonHttpBody
export function xAnyToJsonHttpBody(this_: Codable): HttpBody {
    return new HttpBody(stringify(this_), HttpMediaTypes.INSTANCE.JSON);
}

//! Declares com.lightningkite.butterfly.net.toHttpBody
export function xByteArrayToHttpBody(this_: ArrayBuffer, mediaType: HttpMediaType): HttpBody {
    return new HttpBody(this_, mediaType);
}

//! Declares com.lightningkite.butterfly.net.toHttpBody
export function xStringToHttpBody(this_: string, mediaType: HttpMediaType = HttpMediaTypes.INSTANCE.TEXT): HttpBody {
    return new HttpBody(this_, mediaType);
}

//! Declares com.lightningkite.butterfly.net.toHttpBody
export function xUriToHttpBody(this_: File): Observable<HttpBody> {
    return of(new HttpBody(
        this_,
        this_.type
    ))
}

//! Declares com.lightningkite.butterfly.net.toHttpBody
export function xImageToHttpBody(this_: Image, maxDimension: number = 2048, maxBytes: number = 10_000_000): Observable<HttpBody> {
    return xImageLoad(this_).pipe(
        flatMap((x) => resize(x, maxDimension)),
        map((x) => new HttpBody(x, "image/png"))
    )
}

function resize(image: ImageBitmap, maxDimension: number = 2048): Observable<Blob> {
    return new Observable((em) => {
        try {
            let canvasElement = document.createElement("canvas");
            const wide = image.width > image.height;
            const tooBig = image.width > maxDimension || image.height > maxDimension;
            canvasElement.width = !tooBig ? image.width : (
                wide ? maxDimension : image.width / image.height * maxDimension
            );
            canvasElement.height = !tooBig ? image.height : (
                wide ? image.height / image.width * maxDimension : maxDimension
            );
            const ctx = canvasElement.getContext("2d");
            if (ctx) {
                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                ctx.drawImage(image, 0, 0);
            }
            canvasElement.toBlob((x) => {
                if (x) {
                    em.next(x);
                    em.complete();
                } else {
                    em.error(new Exception("", undefined))
                }
            });
        } catch (e) {
            em.error(e)
        }
    });
}

//! Declares com.lightningkite.butterfly.net.multipartFormBody
export function multipartFormBody(...parts: HttpBodyPart[]): HttpBody {
    const data = new FormData();
    for (const part of parts) {
        if (part.body != null) {
            data.append(part.name, part.body.getBlobOrString(), part.filename ?? "file");
        } else {
            data.append(part.name, part.value as string);
        }
    }
    return new HttpBody(
        data,
        HttpMediaTypes.INSTANCE.MULTIPART_FORM_DATA
    );
}

//! Declares com.lightningkite.butterfly.net.multipartFormFilePart
export function multipartFormFilePart(name: string, valueOrFilename?: string, body?: HttpBody): HttpBodyPart {
    const result = new HttpBodyPart();
    result.name = name;
    if (body) {
        result.filename = valueOrFilename ?? null;
        result.body = body;
    } else {
        result.value = valueOrFilename ?? null;
    }
    return result;
}

//! Declares com.lightningkite.butterfly.net.multipartFormValuePart
export function multipartFormValuePart(name: string, value: string): HttpBodyPart {
    const result = new HttpBodyPart();
    result.name = name;
    result.value = value;
    return result;
}

