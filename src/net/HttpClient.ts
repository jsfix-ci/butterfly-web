// Generated by Butterfly TypeScript converter
// File: net/HttpClient.kt
// Package: com.lightningkite.butterfly.net
import {from, Observable, SchedulerLike, Subject, using} from 'rxjs'
import {ConnectedWebSocket} from "./ConnectedWebSocket";
import {HttpBody} from "./HttpBody";
import {Exception} from "../kotlin/Language";
import {map, mergeMap, timeout} from "rxjs/operators";
import {HttpCacheMode, HttpOptions, HttpPhase, HttpProgress} from "./HttpModels";
import {ObservableProperty} from "../observables/ObservableProperty";
import {xObservableAsObservableProperty} from "../observables/EventToObservableProperty";
import {HttpMediaTypes} from "./HttpMediaType";

//! Declares com.lightningkite.butterfly.net.HttpClient
export class HttpClient {
    public static INSTANCE = new HttpClient();

    public readonly GET = "GET";
    public readonly POST = "POST";
    public readonly PUT = "PUT";
    public readonly PATCH = "PATCH";
    public readonly DELETE = "DELETE";

    //--- HttpClient.ioScheduler
    public ioScheduler: SchedulerLike | null = null

    //--- HttpClient.responseScheduler
    public responseScheduler: SchedulerLike | null = null

    public defaultOptions: HttpOptions = new HttpOptions();

    call(
        url: string,
        method: string = HttpClient.INSTANCE.GET,
        headers: Map<string, string> = new Map([]),
        body: (HttpBody | null) = null,
        options: HttpOptions = this.defaultOptions
    ): Observable<Response> {
        let h = new Array(...headers.entries());
        if(body !== null && body.type !== HttpMediaTypes.INSTANCE.MULTIPART_FORM_DATA){
            h.push(["Content-Type", body.type]);
        }
        let cacheString: RequestCache = "default"
        switch(options.cacheMode) {
            case HttpCacheMode.Default:
                cacheString = "default"
                break
            case HttpCacheMode.NoStore:
                cacheString = "no-store"
                break
            case HttpCacheMode.Reload:
                cacheString = "reload"
                break
            case HttpCacheMode.NoCache:
                cacheString = "no-cache"
                break
            case HttpCacheMode.ForceCache:
                cacheString = "force-cache"
                break
            case HttpCacheMode.OnlyIfCached:
                cacheString = "only-if-cached"
                break
        }
        return from(fetch(url, {
            body: body?.data,
            cache: cacheString,
            credentials: "omit",
            headers: h,
            method: method
        })).pipe(timeout(options.callTimeout ?? (
            (options.connectTimeout ?? 5_000) + (options.readTimeout ?? 5_000) + (options.writeTimeout ?? 5_000)
        )))
    }

    callWithProgress<T>(
        url: string,
        method: string = HttpClient.INSTANCE.GET,
        headers: Map<string, string> = new Map([]),
        body: (HttpBody | null) = null,
        options: HttpOptions = this.defaultOptions,
        parse: (response: Response) => Observable<T>
    ): Observable<HttpProgress<T>> {
        return this.call(url, method, headers, body, options).pipe(mergeMap(parse), map(x => new HttpProgress(HttpPhase.Done, 1, x)))
    }
    
    webSocket(url: string): Observable<ConnectedWebSocket>{
        return using<ConnectedWebSocket>(
            ()=> {
                const out = new ConnectedWebSocket(url)
                // out.underlyingSocket =
                return out
            },
            (r) => (r as ConnectedWebSocket).ownConnection
        )
    }
}

function approximateCompletion(x: number): number {
    return 1 - 1 / (x * 10_000 + 1)
}