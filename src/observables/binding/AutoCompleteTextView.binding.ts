// Generated by Butterfly TypeScript converter
// File: observables/binding/AutoCompleteTextView.binding.kt
// Package: com.lightningkite.butterfly.observables.binding
import {ObservableProperty} from '../ObservableProperty'
import {
    xViewRemovedGet,
    xDisposableUntil,
    xDisposableUntil as until,
    xViewRemovedGet as vRemoved
} from "../../rx/DisposeCondition.ext";
import {xObservablePropertySubscribeBy as subBy, xObservablePropertySubscribeBy} from "../ObservableProperty.ext";
import {xObservablePropertyCombine} from "../CombineObservableProperty";
import {StandardObservableProperty} from "../StandardObservableProperty";
import {v4} from 'uuid'
import {DisposableLambda} from "../../rx/DisposableLambda";
import {triggerDetatchEvent} from "../../views/viewAttached";

//! Declares com.lightningkite.butterfly.observables.binding.bind>android.widget.AutoCompleteTextView
export function xAutoCompleteTextViewBind<T>(this_: HTMLInputElement, options: ObservableProperty<Array<T>>, toString: (a: T) => string, onItemSelected: (a: T) => void): void {
    let query = new StandardObservableProperty("")
    this_.addEventListener("change", ()=>{
        query.value = this_.value;
    });
    xAutoCompleteTextViewBindList(
        this_,
        xObservablePropertyCombine(
            options,
            query,
            (options, query) => options.filter((x) => toString(x).toLowerCase().indexOf(query.toLowerCase()) != -1)
        ),
        toString,
        onItemSelected
    );
}
//! Declares com.lightningkite.butterfly.observables.binding.bindList>android.widget.AutoCompleteTextView
export function xAutoCompleteTextViewBindList<T>(this_: HTMLInputElement, options: ObservableProperty<Array<T>>, toString: (a: T) => string, onItemSelected: (a: T) => void): void {
    let optionMap = new Map(options.value.map(x => [toString(x), x]))
    const observables = options.value.map((x) => {
        return new StandardObservableProperty(x)
    })
    const dataListElement = document.createElement("datalist")
    dataListElement.id = v4()
    document.body.appendChild(dataListElement)
    const listAttr = document.createAttribute("list")
    listAttr.value = dataListElement.id
    this_.attributes.setNamedItem(listAttr)
    xDisposableUntil(xObservablePropertySubscribeBy(options, undefined, undefined, (options)=>{
        optionMap = new Map(options.map(x => [toString(x), x]))
        const this_ = dataListElement
        //correct number of options
        const diff = options.length - this_.options.length;
        if (diff > 0) {
            for (let i = 0; i < diff; i++) {
                const newOpt = document.createElement("option");
                newOpt.value = (options.length - 1 - diff + i).toString();
                const newObs = new StandardObservableProperty(options[options.length - diff + i]);
                until(subBy(newObs, undefined, undefined, (x) => {
                    const s = toString(x);
                    newOpt.value = s
                }), vRemoved(newOpt))
                this_.appendChild(newOpt);
                observables.push(newObs);
            }
        } else if (diff < 0) {
            for(let i = 0; i < -diff; i++){
                const opt = this_.options.item(this_.options.length-1);
                triggerDetatchEvent(opt as HTMLOptionElement);
                this_.removeChild(this_.lastChild!);
                observables.pop();
            }
        }
        for(let i = 0; i < options.length; i++){
            observables[i].value = options[i]
        }
    }), xViewRemovedGet(this_))
    xViewRemovedGet(this_).call(new DisposableLambda(() => {
        document.body.removeChild(dataListElement)
    }))
    this_.addEventListener("input", (ev)=> {
        const sel = optionMap.get(this_.value);
        if(sel !== undefined){
            onItemSelected(sel)
        }
    })
}