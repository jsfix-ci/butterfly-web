// Generated by Butterfly TypeScript converter 
// File: observables/binding/RecyclerView.binding.kt
// Package: com.lightningkite.butterfly.observables.binding
import {xObservablePropertySubscribeBy} from '../ObservableProperty.ext'
import {newEmptyView} from '../../views/EmptyView'
import {xViewRemovedGet, xDisposableUntil} from '../../rx/DisposeCondition.ext'
import {ObservableProperty} from '../ObservableProperty'
import {StandardObservableProperty} from '../StandardObservableProperty'
import {xObservablePropertyMap} from '../TransformedObservableProperty'
import {MutableObservableProperty} from '../MutableObservableProperty'
import {also, checkReified, NumberRange, tryCastClass} from '../../Kotlin'
import {xLinearLayoutBind} from "./LinearLayout.binding";
import {xLinearLayoutParams} from "../../views/LinearLayout";
import {AlignPair} from "../../views/geometry/Align";
import {range} from "iterable-operator";
import {triggerDetatchEvent} from "../../views/viewAttached";

//! Declares com.lightningkite.butterfly.observables.binding.whenScrolledToEnd>androidx.recyclerview.widget.RecyclerView
export function xRecyclerViewWhenScrolledToEnd(this_: HTMLDivElement, action: () => void): void {
    this_.addEventListener("scroll", (ev) => {
        if (this_.scrollTop >= this_.scrollHeight - this_.offsetHeight - 10) {
            action()
        }
    })
}

//! Declares com.lightningkite.butterfly.observables.binding.reverseDirection>androidx.recyclerview.widget.RecyclerView
export function xRecyclerViewReverseDirectionGet(this_: HTMLDivElement): boolean {
    return this_.style.flexDirection.endsWith("reverse")
}

export function xRecyclerViewReverseDirectionSet(this_: HTMLDivElement, value: boolean) {
    const existing = this_.style.flexDirection
    if (existing.startsWith("row")) {
        if (value) {
            this_.style.flexDirection = "row-reverse"
        } else {
            this_.style.flexDirection = "row"
        }
    } else {
        if (value) {
            this_.style.flexDirection = "column-reverse"
        } else {
            this_.style.flexDirection = "column"
        }
    }
    return
}


//! Declares com.lightningkite.butterfly.observables.binding.bind>androidx.recyclerview.widget.RecyclerView
export function xRecyclerViewBind<T>(this_: HTMLDivElement, data: ObservableProperty<Array<T>>, defaultValue: T, makeView: (a: ObservableProperty<T>) => HTMLElement): void {
    xLinearLayoutBind(this_, data, defaultValue, makeView)
}

//! Declares com.lightningkite.butterfly.observables.binding.RVTypeHandler
interface RvTypeHandlerHandler<T> {
    type: Array<any>
    defaultValue: T
    action: (a: ObservableProperty<T>) => HTMLElement
    buffer: Array<[StandardObservableProperty<T>, HTMLElement]>
}
export class RVTypeHandler {
    public handlers: Array<RvTypeHandlerHandler<any>> = [];
    public handle<T extends any>(T: Array<any>, defaultValue: T, action: (a: ObservableProperty<T>) => HTMLElement): void {
        this.handlers.push({
            type: T,
            defaultValue: defaultValue,
            action: action,
            buffer: []
        })
    }
}

//! Declares com.lightningkite.butterfly.observables.binding.bindMulti>androidx.recyclerview.widget.RecyclerView
export function recyclerViewBindMultiType(this_: HTMLDivElement, viewDependency: Window, data: ObservableProperty<Array<any>>, typeHandlerSetup: (a: RVTypeHandler) => void): void {
    const h = new RVTypeHandler();
    typeHandlerSetup(h);
    xRecyclerViewBindMulti(
        this_,
        data,
        null,
        (x) => h.handlers.findIndex((handler) => checkReified(x, handler.type)),
        (type, prop) => {
            const handler = h.handlers[type]
            if(handler){
                return handler.action(prop);
            } else {
                return document.createElement("div")
            }
        }
    )
}


//! Declares com.lightningkite.butterfly.observables.binding.bindMulti>androidx.recyclerview.widget.RecyclerView
export function xRecyclerViewBindMulti<T>(this_: HTMLDivElement, data: ObservableProperty<Array<T>>, defaultValue: T, determineType: (a: T) => number, makeView: (a: number, b: ObservableProperty<T>) => HTMLElement): void {
    let existingViews: Map<number, Array<[StandardObservableProperty<T>, HTMLElement]>> = new Map();
    xDisposableUntil(xObservablePropertySubscribeBy(data, undefined, undefined, (value) => {

        //Place views
        const unusedViews = existingViews;
        while (this_.firstElementChild) {
            this_.firstElementChild.remove();
        }
        existingViews = new Map();
        for (const item of value) {
            const type = determineType(item);
            const view = unusedViews.get(type)?.pop() ?? (() => {
                const obs = new StandardObservableProperty(item);
                return [obs, makeView(type, obs)] as [StandardObservableProperty<T>, HTMLElement];
            })()
            view[0].value = item;
            if(this_.style.flexDirection.startsWith("column")){
                view[1].style.width = "100%";
            } else {
                view[1].style.height = "100%";
            }
            this_.appendChild(view[1]);
            const sublist = existingViews.get(type) ?? [];
            sublist.push(view);
            existingViews.set(type, sublist);
        }
        for (const entry of unusedViews) {
            for (const part of entry[1]) {
                triggerDetatchEvent(part[1]);
            }
        }
    }), xViewRemovedGet(this_));
}


//! Declares com.lightningkite.butterfly.observables.binding.bindRefresh>androidx.recyclerview.widget.RecyclerView
export function xRecyclerViewBindRefresh(this_: HTMLDivElement, loading: ObservableProperty<boolean>, refresh: () => void): void {
    const actualRefreshView = this_.parentElement as HTMLElement;
    let actualRefreshButton: HTMLElement | null = null;
    for (let i = 0; i < actualRefreshView.children.length; i++) {
        const view = actualRefreshView.children.item(i) as Element;
        if (view.classList.contains("butterfly-refresh-button")) {
            actualRefreshButton = view as HTMLElement;
        }
    }
    if (actualRefreshButton) {
        actualRefreshButton.onclick = (x) => {
            refresh();
        };
        xDisposableUntil(xObservablePropertySubscribeBy(loading, undefined, undefined, (x) => {
            if(actualRefreshButton){
                if (x) {
                    actualRefreshButton.classList.add("butterfly-refresh-button-loading")
                } else {
                    actualRefreshButton.classList.remove("butterfly-refresh-button-loading")
                }
            }
        }), xViewRemovedGet(actualRefreshButton))
    }
}


